package configfile

import (
	"fmt"
	"sort"
	"strings"
)

// GhosttyWriter implements the Writer interface for Ghostty config format.
// Ghostty uses a simple key = value format with no sections.
// Special handling: list values emit multiple lines with the same key.
type GhosttyWriter struct{}

func init() {
	Register(&GhosttyWriter{})
}

// NewGhosttyWriter creates a new Ghostty config writer.
func NewGhosttyWriter() *GhosttyWriter {
	return &GhosttyWriter{}
}

// Format returns the format identifier.
func (w *GhosttyWriter) Format() string {
	return "ghostty"
}

// Write generates Ghostty config content from values.
func (w *GhosttyWriter) Write(values map[string]any) ([]byte, error) {
	var b strings.Builder

	b.WriteString("# Ghostty Configuration\n")
	b.WriteString("# Generated by acorn - do not edit manually\n")
	b.WriteString("# https://ghostty.org/docs/config\n\n")

	// Sort keys for deterministic output
	keys := make([]string, 0, len(values))
	for k := range values {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		value := values[key]

		// Handle list values - emit multiple lines with same key
		if list, ok := ghosttyToStringSlice(value); ok {
			for _, item := range list {
				b.WriteString(fmt.Sprintf("%s = %s\n", key, item))
			}
			continue
		}

		// Handle scalar values
		b.WriteString(fmt.Sprintf("%s = %s\n", key, formatValue(value)))
	}

	return []byte(b.String()), nil
}

// ghosttyToStringSlice converts various list types to []string.
func ghosttyToStringSlice(v any) ([]string, bool) {
	switch val := v.(type) {
	case []string:
		return val, true
	case []any:
		result := make([]string, 0, len(val))
		for _, item := range val {
			result = append(result, fmt.Sprintf("%v", item))
		}
		return result, true
	default:
		return nil, false
	}
}

// formatValue formats a value for Ghostty config.
func formatValue(v any) string {
	switch val := v.(type) {
	case string:
		// Quote strings with spaces, otherwise unquoted
		if strings.Contains(val, " ") {
			return fmt.Sprintf("%q", val)
		}
		return val
	case bool:
		if val {
			return "true"
		}
		return "false"
	default:
		return fmt.Sprintf("%v", val)
	}
}
