package configfile

import (
	"fmt"
	"sort"
	"strings"
)

// GitConfigWriter implements the Writer interface for git config format.
// Generates INI-style config with sections, subsections, and multi-value support.
//
// Expected structure:
//
//	core:
//	  editor: nvim
//	user:
//	  name: "Your Name"
//	  email: "you@example.com"
//	alias:
//	  s: status
//	  co: checkout
//	credential:
//	  "https://github.com":
//	    helper:
//	      - ""
//	      - "!/opt/homebrew/bin/gh auth git-credential"
//	includeIf:
//	  "gitdir:~/Repos/work/":
//	    path: "~/.config/git/config.work"
type GitConfigWriter struct{}

func init() {
	Register(&GitConfigWriter{})
}

// NewGitConfigWriter creates a new git config writer.
func NewGitConfigWriter() *GitConfigWriter {
	return &GitConfigWriter{}
}

// Format returns the format identifier.
func (w *GitConfigWriter) Format() string {
	return "gitconfig"
}

// Write generates git config content from values.
func (w *GitConfigWriter) Write(values map[string]any) ([]byte, error) {
	var b strings.Builder

	b.WriteString("# Git Configuration\n")
	b.WriteString("# Generated by acorn - do not edit manually\n\n")

	// Define section order for readable output
	sectionOrder := []string{
		"core", "user", "init", "color", "alias",
		"push", "pull", "fetch", "merge", "rebase", "diff",
		"credential", "include", "includeIf",
	}

	// Write known sections first in order
	written := make(map[string]bool)
	for _, section := range sectionOrder {
		if val, ok := values[section]; ok {
			if err := w.writeSection(&b, section, val); err != nil {
				return nil, err
			}
			written[section] = true
		}
	}

	// Write any remaining sections alphabetically
	remaining := make([]string, 0)
	for section := range values {
		if !written[section] {
			remaining = append(remaining, section)
		}
	}
	sort.Strings(remaining)
	for _, section := range remaining {
		if err := w.writeSection(&b, section, values[section]); err != nil {
			return nil, err
		}
	}

	return []byte(b.String()), nil
}

// writeSection writes a section with its values.
func (w *GitConfigWriter) writeSection(b *strings.Builder, name string, value any) error {
	switch v := value.(type) {
	case map[string]any:
		// Check if this is a subsection container (like credential or includeIf)
		if w.hasSubsections(v) {
			return w.writeSubsections(b, name, v)
		}
		// Regular section with key-value pairs
		fmt.Fprintf(b, "[%s]\n", name)
		w.writeKeyValues(b, v)
		b.WriteString("\n")

	case []any:
		// Special handling for include (list of paths)
		if name == "include" && len(v) > 0 {
			b.WriteString("[include]\n")
			for _, path := range v {
				fmt.Fprintf(b, "\tpath = %s\n", path)
			}
			b.WriteString("\n")
		}
	}

	return nil
}

// hasSubsections checks if a map contains nested maps (subsections).
func (w *GitConfigWriter) hasSubsections(m map[string]any) bool {
	for _, v := range m {
		if _, ok := v.(map[string]any); ok {
			return true
		}
	}
	return false
}

// writeSubsections writes sections with subsection names like [credential "url"].
func (w *GitConfigWriter) writeSubsections(b *strings.Builder, section string, subsections map[string]any) error {
	// Sort subsection names for deterministic output
	names := make([]string, 0, len(subsections))
	for name := range subsections {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		val := subsections[name]
		if m, ok := val.(map[string]any); ok {
			fmt.Fprintf(b, "[%s %q]\n", section, name)
			w.writeKeyValues(b, m)
			b.WriteString("\n")
		}
	}

	return nil
}

// writeKeyValues writes key-value pairs with proper indentation.
func (w *GitConfigWriter) writeKeyValues(b *strings.Builder, m map[string]any) {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		val := m[key]
		// Handle multi-value keys (arrays)
		if arr, ok := toGitconfigSlice(val); ok {
			for _, item := range arr {
				fmt.Fprintf(b, "\t%s = %s\n", key, item)
			}
		} else {
			fmt.Fprintf(b, "\t%s = %s\n", key, formatGitconfigValue(val))
		}
	}
}

// toGitconfigSlice converts an any to a string slice if it's an array type.
func toGitconfigSlice(v any) ([]string, bool) {
	switch val := v.(type) {
	case []string:
		return val, true
	case []any:
		result := make([]string, 0, len(val))
		for _, item := range val {
			result = append(result, fmt.Sprintf("%v", item))
		}
		return result, true
	default:
		return nil, false
	}
}

// formatGitconfigValue formats a value for git config output.
func formatGitconfigValue(v any) string {
	switch val := v.(type) {
	case string:
		return val
	case bool:
		if val {
			return "true"
		}
		return "false"
	case int, int64, float64:
		return fmt.Sprintf("%v", val)
	default:
		return fmt.Sprintf("%v", val)
	}
}
