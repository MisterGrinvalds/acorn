package configfile

import (
	"strings"
	"testing"
)

func TestGhosttyWriterFormat(t *testing.T) {
	w := &GhosttyWriter{}
	if w.Format() != "ghostty" {
		t.Errorf("Format() = %q, want %q", w.Format(), "ghostty")
	}
}

func TestGhosttyWriterBasicValues(t *testing.T) {
	w := &GhosttyWriter{}

	values := map[string]interface{}{
		"theme":     "Catppuccin Mocha",
		"font-size": 14,
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "# Ghostty Configuration") {
		t.Error("Missing header comment")
	}

	if !strings.Contains(output, "# Generated by acorn") {
		t.Error("Missing generated comment")
	}

	// Check values (keys are sorted alphabetically)
	if !strings.Contains(output, "font-size = 14") {
		t.Error("Missing font-size value")
	}

	if !strings.Contains(output, "theme = \"Catppuccin Mocha\"") {
		t.Error("Missing theme value (should be quoted due to space)")
	}
}

func TestGhosttyWriterStringQuoting(t *testing.T) {
	w := &GhosttyWriter{}

	tests := []struct {
		name     string
		values   map[string]interface{}
		expected string
	}{
		{
			name:     "string without spaces - no quotes",
			values:   map[string]interface{}{"theme": "dark"},
			expected: "theme = dark",
		},
		{
			name:     "string with spaces - quoted",
			values:   map[string]interface{}{"font-family": "JetBrains Mono"},
			expected: `font-family = "JetBrains Mono"`,
		},
		{
			name:     "empty string",
			values:   map[string]interface{}{"value": ""},
			expected: "value = ",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			content, err := w.Write(tt.values)
			if err != nil {
				t.Fatalf("Write failed: %v", err)
			}

			if !strings.Contains(string(content), tt.expected) {
				t.Errorf("Output doesn't contain %q\nGot:\n%s", tt.expected, content)
			}
		})
	}
}

func TestGhosttyWriterBooleans(t *testing.T) {
	w := &GhosttyWriter{}

	values := map[string]interface{}{
		"font-thicken":    true,
		"cursor-blink":    false,
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, "font-thicken = true") {
		t.Error("Boolean true not formatted correctly")
	}

	if !strings.Contains(output, "cursor-blink = false") {
		t.Error("Boolean false not formatted correctly")
	}
}

func TestGhosttyWriterIntegers(t *testing.T) {
	w := &GhosttyWriter{}

	values := map[string]interface{}{
		"font-size":        14,
		"scrollback-limit": 50000,
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, "font-size = 14") {
		t.Error("Integer not formatted correctly")
	}

	if !strings.Contains(output, "scrollback-limit = 50000") {
		t.Error("Large integer not formatted correctly")
	}
}

func TestGhosttyWriterListValues(t *testing.T) {
	w := &GhosttyWriter{}

	// Test with []string
	values := map[string]interface{}{
		"keybind": []string{
			"super+d=new_split:right",
			"super+t=new_tab",
			"super+w=close_surface",
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Each keybind should be on its own line with same key
	if !strings.Contains(output, "keybind = super+d=new_split:right") {
		t.Error("First keybind not found")
	}

	if !strings.Contains(output, "keybind = super+t=new_tab") {
		t.Error("Second keybind not found")
	}

	if !strings.Contains(output, "keybind = super+w=close_surface") {
		t.Error("Third keybind not found")
	}

	// Count occurrences of "keybind ="
	count := strings.Count(output, "keybind = ")
	if count != 3 {
		t.Errorf("Expected 3 keybind lines, got %d", count)
	}
}

func TestGhosttyWriterListValuesInterface(t *testing.T) {
	w := &GhosttyWriter{}

	// Test with []interface{} (how YAML unmarshals lists)
	values := map[string]interface{}{
		"keybind": []interface{}{
			"super+d=new_split:right",
			"super+t=new_tab",
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, "keybind = super+d=new_split:right") {
		t.Error("First keybind not found")
	}

	if !strings.Contains(output, "keybind = super+t=new_tab") {
		t.Error("Second keybind not found")
	}
}

func TestGhosttyWriterKeysSorted(t *testing.T) {
	w := &GhosttyWriter{}

	values := map[string]interface{}{
		"zebra":    "last",
		"alpha":    "first",
		"middle":   "middle",
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Find positions of each key
	alphaPos := strings.Index(output, "alpha = ")
	middlePos := strings.Index(output, "middle = ")
	zebraPos := strings.Index(output, "zebra = ")

	if alphaPos > middlePos || middlePos > zebraPos {
		t.Error("Keys are not sorted alphabetically")
	}
}

func TestGhosttyWriterEmptyValues(t *testing.T) {
	w := &GhosttyWriter{}

	values := map[string]interface{}{}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Should still have header
	if !strings.Contains(output, "# Ghostty Configuration") {
		t.Error("Missing header even with empty values")
	}
}

func TestGhosttyWriterComplexConfig(t *testing.T) {
	w := &GhosttyWriter{}

	// Realistic Ghostty config
	values := map[string]interface{}{
		"theme":                        "Catppuccin Mocha",
		"font-family":                  "JetBrainsMono Nerd Font",
		"font-size":                    14,
		"font-thicken":                 true,
		"window-padding-x":             8,
		"window-padding-y":             8,
		"cursor-style":                 "block",
		"cursor-style-blink":           false,
		"scrollback-limit":             50000,
		"clipboard-read":               "allow",
		"clipboard-write":              "allow",
		"keybind": []string{
			"super+d=new_split:right",
			"super+shift+d=new_split:down",
			"super+t=new_tab",
			"super+w=close_surface",
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Verify structure
	lines := strings.Split(output, "\n")

	// Should have header comments at top
	if !strings.HasPrefix(lines[0], "#") {
		t.Error("First line should be a comment")
	}

	// Count non-empty, non-comment lines
	dataLines := 0
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line != "" && !strings.HasPrefix(line, "#") {
			dataLines++
		}
	}

	// 11 scalar values + 4 keybinds = 15 data lines
	expectedDataLines := 15
	if dataLines != expectedDataLines {
		t.Errorf("Expected %d data lines, got %d", expectedDataLines, dataLines)
	}
}

func TestToStringSlice(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected []string
		ok       bool
	}{
		{
			name:     "[]string",
			input:    []string{"a", "b", "c"},
			expected: []string{"a", "b", "c"},
			ok:       true,
		},
		{
			name:     "[]interface{} with strings",
			input:    []interface{}{"a", "b", "c"},
			expected: []string{"a", "b", "c"},
			ok:       true,
		},
		{
			name:     "[]interface{} with mixed types",
			input:    []interface{}{"a", 123, true},
			expected: []string{"a", "123", "true"},
			ok:       true,
		},
		{
			name:     "string (not a slice)",
			input:    "just a string",
			expected: nil,
			ok:       false,
		},
		{
			name:     "int (not a slice)",
			input:    42,
			expected: nil,
			ok:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, ok := toStringSlice(tt.input)

			if ok != tt.ok {
				t.Errorf("toStringSlice() ok = %v, want %v", ok, tt.ok)
				return
			}

			if tt.ok {
				if len(result) != len(tt.expected) {
					t.Errorf("toStringSlice() len = %d, want %d", len(result), len(tt.expected))
					return
				}

				for i, v := range result {
					if v != tt.expected[i] {
						t.Errorf("toStringSlice()[%d] = %q, want %q", i, v, tt.expected[i])
					}
				}
			}
		})
	}
}

func TestFormatValue(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected string
	}{
		{
			name:     "string without spaces",
			input:    "dark",
			expected: "dark",
		},
		{
			name:     "string with spaces",
			input:    "Catppuccin Mocha",
			expected: `"Catppuccin Mocha"`,
		},
		{
			name:     "bool true",
			input:    true,
			expected: "true",
		},
		{
			name:     "bool false",
			input:    false,
			expected: "false",
		},
		{
			name:     "integer",
			input:    42,
			expected: "42",
		},
		{
			name:     "float",
			input:    3.14,
			expected: "3.14",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := formatValue(tt.input)
			if result != tt.expected {
				t.Errorf("formatValue(%v) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}
