package configfile

import (
	"fmt"
	"sort"
	"strings"
)

// TmuxWriter implements the Writer interface for tmux config format.
// Tmux uses command-based syntax: set -g option value, bind key command, etc.
type TmuxWriter struct{}

func init() {
	Register(&TmuxWriter{})
}

// Format returns the format identifier.
func (w *TmuxWriter) Format() string {
	return "tmux"
}

// Write generates tmux config content from values.
// Expected structure:
//
//	set_g: map of global options (set -g)
//	set_s: map of server options (set -s)
//	set_w: map of window options (set -w)
//	set_ga: map of append options (set -ga)
//	set_as: list of append server options (set -as)
//	terminal_features: list of terminal feature strings
//	bind: map of prefix key bindings
//	bind_n: map of no-prefix key bindings
//	bind_r: map of repeatable key bindings
//	bind_T: map of table -> key -> command bindings
//	unbind: list of keys to unbind
//	unbind_n: list of no-prefix keys to unbind
//	plugins: list of TPM plugin strings
//	plugin_options: map of plugin options (@option)
//	raw: list of raw config lines (for conditionals, etc.)
//	run: list of commands to run
func (w *TmuxWriter) Write(values map[string]interface{}) ([]byte, error) {
	var b strings.Builder

	b.WriteString("# =============================================================================\n")
	b.WriteString("# Tmux Configuration\n")
	b.WriteString("# =============================================================================\n")
	b.WriteString("# Generated by acorn - do not edit manually\n\n")

	// Write sections in order
	w.writeSetOptions(&b, values, "set_g", "-g", "General Settings")
	w.writeSetOptions(&b, values, "set_s", "-s", "Server Settings")
	w.writeSetOptions(&b, values, "set_w", "-w", "Window Settings")
	w.writeAppendOptions(&b, values)
	w.writeTerminalFeatures(&b, values)
	w.writeUnbinds(&b, values)
	w.writeBindings(&b, values)
	w.writeRaw(&b, values)
	w.writePlugins(&b, values)
	w.writeRun(&b, values)

	return []byte(b.String()), nil
}

// writeSetOptions writes set commands for a given flag.
func (w *TmuxWriter) writeSetOptions(b *strings.Builder, values map[string]interface{}, key, flag, header string) {
	opts, ok := values[key].(map[string]interface{})
	if !ok || len(opts) == 0 {
		return
	}

	b.WriteString(fmt.Sprintf("# %s\n", header))

	keys := sortedKeys(opts)
	for _, k := range keys {
		v := opts[k]
		b.WriteString(fmt.Sprintf("set %s %s %s\n", flag, k, formatTmuxValue(v)))
	}
	b.WriteString("\n")
}

// writeAppendOptions writes set -ga and set -as options.
func (w *TmuxWriter) writeAppendOptions(b *strings.Builder, values map[string]interface{}) {
	// set -ga options
	if opts, ok := values["set_ga"].(map[string]interface{}); ok && len(opts) > 0 {
		keys := sortedKeys(opts)
		for _, k := range keys {
			v := opts[k]
			b.WriteString(fmt.Sprintf("set -ga %s %s\n", k, formatTmuxValue(v)))
		}
	}

	// set -as options (list format)
	if opts, ok := toTmuxStringSlice(values["set_as"]); ok {
		for _, opt := range opts {
			b.WriteString(fmt.Sprintf("set -as %s\n", opt))
		}
	}
	b.WriteString("\n")
}

// writeTerminalFeatures writes terminal-features settings.
func (w *TmuxWriter) writeTerminalFeatures(b *strings.Builder, values map[string]interface{}) {
	features, ok := toTmuxStringSlice(values["terminal_features"])
	if !ok || len(features) == 0 {
		return
	}

	b.WriteString("# Terminal Features\n")
	for _, f := range features {
		b.WriteString(fmt.Sprintf("set -as terminal-features '%s'\n", f))
	}
	b.WriteString("\n")
}

// writeUnbinds writes unbind commands.
func (w *TmuxWriter) writeUnbinds(b *strings.Builder, values map[string]interface{}) {
	hasUnbinds := false

	if keys, ok := toTmuxStringSlice(values["unbind"]); ok && len(keys) > 0 {
		if !hasUnbinds {
			b.WriteString("# Unbindings\n")
			hasUnbinds = true
		}
		for _, k := range keys {
			b.WriteString(fmt.Sprintf("unbind %s\n", k))
		}
	}

	if keys, ok := toTmuxStringSlice(values["unbind_n"]); ok && len(keys) > 0 {
		if !hasUnbinds {
			b.WriteString("# Unbindings\n")
			hasUnbinds = true
		}
		for _, k := range keys {
			b.WriteString(fmt.Sprintf("unbind -n %s\n", k))
		}
	}

	if hasUnbinds {
		b.WriteString("\n")
	}
}

// writeBindings writes key bindings.
func (w *TmuxWriter) writeBindings(b *strings.Builder, values map[string]interface{}) {
	hasBindings := false

	// Regular prefix bindings
	if binds, ok := values["bind"].(map[string]interface{}); ok && len(binds) > 0 {
		b.WriteString("# Key Bindings\n")
		hasBindings = true
		keys := sortedKeys(binds)
		for _, k := range keys {
			v := binds[k]
			b.WriteString(fmt.Sprintf("bind %s %s\n", k, formatTmuxValue(v)))
		}
		b.WriteString("\n")
	}

	// No-prefix bindings
	if binds, ok := values["bind_n"].(map[string]interface{}); ok && len(binds) > 0 {
		if !hasBindings {
			b.WriteString("# Key Bindings\n")
		}
		b.WriteString("# No-prefix bindings\n")
		keys := sortedKeys(binds)
		for _, k := range keys {
			v := binds[k]
			b.WriteString(fmt.Sprintf("bind -n %s %s\n", k, formatTmuxValue(v)))
		}
		b.WriteString("\n")
	}

	// Repeatable bindings
	if binds, ok := values["bind_r"].(map[string]interface{}); ok && len(binds) > 0 {
		b.WriteString("# Repeatable bindings\n")
		keys := sortedKeys(binds)
		for _, k := range keys {
			v := binds[k]
			b.WriteString(fmt.Sprintf("bind -r %s %s\n", k, formatTmuxValue(v)))
		}
		b.WriteString("\n")
	}

	// Table-specific bindings (bind -T table key command)
	if tables, ok := values["bind_T"].(map[string]interface{}); ok && len(tables) > 0 {
		for table, tableBinds := range tables {
			binds, ok := tableBinds.(map[string]interface{})
			if !ok {
				continue
			}
			b.WriteString(fmt.Sprintf("# %s bindings\n", table))
			keys := sortedKeys(binds)
			for _, k := range keys {
				v := binds[k]
				b.WriteString(fmt.Sprintf("bind -T %s %s %s\n", table, k, formatTmuxValue(v)))
			}
			b.WriteString("\n")
		}
	}
}

// writeRaw writes raw config lines.
func (w *TmuxWriter) writeRaw(b *strings.Builder, values map[string]interface{}) {
	raw, ok := toTmuxStringSlice(values["raw"])
	if !ok || len(raw) == 0 {
		return
	}

	for _, line := range raw {
		b.WriteString(line)
		b.WriteString("\n")
	}
	b.WriteString("\n")
}

// writePlugins writes TPM plugin configuration.
func (w *TmuxWriter) writePlugins(b *strings.Builder, values map[string]interface{}) {
	plugins, ok := toTmuxStringSlice(values["plugins"])
	if !ok || len(plugins) == 0 {
		return
	}

	b.WriteString("# =============================================================================\n")
	b.WriteString("# TPM (Tmux Plugin Manager)\n")
	b.WriteString("# =============================================================================\n")
	b.WriteString("# Install: git clone https://github.com/tmux-plugins/tpm ~/.config/tmux/plugins/tpm\n")
	b.WriteString("# Press prefix + I to install plugins\n\n")

	for _, plugin := range plugins {
		b.WriteString(fmt.Sprintf("set -g @plugin '%s'\n", plugin))
	}

	// Plugin options
	if opts, ok := values["plugin_options"].(map[string]interface{}); ok && len(opts) > 0 {
		b.WriteString("\n# Plugin settings\n")
		keys := sortedKeys(opts)
		for _, k := range keys {
			v := opts[k]
			b.WriteString(fmt.Sprintf("set -g @%s %s\n", k, formatTmuxValue(v)))
		}
	}

	b.WriteString("\n")
}

// writeRun writes run commands (typically TPM initialization).
func (w *TmuxWriter) writeRun(b *strings.Builder, values map[string]interface{}) {
	runs, ok := toTmuxStringSlice(values["run"])
	if !ok || len(runs) == 0 {
		return
	}

	b.WriteString("# Initialize plugins\n")
	for _, cmd := range runs {
		b.WriteString(fmt.Sprintf("run -b '%s'\n", cmd))
	}
}

// toTmuxStringSlice converts various list types to []string.
func toTmuxStringSlice(v interface{}) ([]string, bool) {
	if v == nil {
		return nil, false
	}
	switch val := v.(type) {
	case []string:
		return val, true
	case []interface{}:
		result := make([]string, 0, len(val))
		for _, item := range val {
			result = append(result, fmt.Sprintf("%v", item))
		}
		return result, true
	default:
		return nil, false
	}
}

// formatTmuxValue formats a value for tmux config.
func formatTmuxValue(v interface{}) string {
	switch val := v.(type) {
	case string:
		return val
	case bool:
		if val {
			return "on"
		}
		return "off"
	case int, int64, float64:
		return fmt.Sprintf("%v", val)
	default:
		return fmt.Sprintf("%v", val)
	}
}

// sortedKeys returns sorted keys from a map.
func sortedKeys(m map[string]interface{}) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}
