package configfile

import (
	"strings"
	"testing"
)

func TestGitconfigWriterFormat(t *testing.T) {
	w := &GitconfigWriter{}
	if w.Format() != "gitconfig" {
		t.Errorf("Format() = %q, want %q", w.Format(), "gitconfig")
	}
}

func TestGitconfigWriterBasicSection(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"core": map[string]interface{}{
			"editor": "nvim",
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "# Git Configuration") {
		t.Error("Missing header comment")
	}

	if !strings.Contains(output, "# Generated by acorn") {
		t.Error("Missing generated comment")
	}

	// Check section
	if !strings.Contains(output, "[core]") {
		t.Error("Missing [core] section")
	}

	if !strings.Contains(output, "\teditor = nvim") {
		t.Error("Missing editor value with tab indent")
	}
}

func TestGitconfigWriterMultipleSections(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"core": map[string]interface{}{
			"editor": "nvim",
		},
		"user": map[string]interface{}{
			"name":  "Test User",
			"email": "test@example.com",
		},
		"color": map[string]interface{}{
			"ui": "auto",
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Check all sections present
	if !strings.Contains(output, "[core]") {
		t.Error("Missing [core] section")
	}
	if !strings.Contains(output, "[user]") {
		t.Error("Missing [user] section")
	}
	if !strings.Contains(output, "[color]") {
		t.Error("Missing [color] section")
	}

	// Check values
	if !strings.Contains(output, "\tname = Test User") {
		t.Error("Missing name value")
	}
	if !strings.Contains(output, "\temail = test@example.com") {
		t.Error("Missing email value")
	}
}

func TestGitconfigWriterSectionOrder(t *testing.T) {
	w := &GitconfigWriter{}

	// Sections should be ordered: core, user, color (per sectionOrder)
	values := map[string]interface{}{
		"color": map[string]interface{}{"ui": "auto"},
		"user":  map[string]interface{}{"name": "Test"},
		"core":  map[string]interface{}{"editor": "nvim"},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	corePos := strings.Index(output, "[core]")
	userPos := strings.Index(output, "[user]")
	colorPos := strings.Index(output, "[color]")

	if corePos > userPos || userPos > colorPos {
		t.Errorf("Sections not in expected order: core=%d, user=%d, color=%d", corePos, userPos, colorPos)
	}
}

func TestGitconfigWriterAliases(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"alias": map[string]interface{}{
			"s":   "status",
			"co":  "checkout",
			"cob": "checkout -b",
			"lg":  "log --graph --pretty=format:'%h %s'",
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, "[alias]") {
		t.Error("Missing [alias] section")
	}

	if !strings.Contains(output, "\ts = status") {
		t.Error("Missing 's' alias")
	}

	if !strings.Contains(output, "\tco = checkout") {
		t.Error("Missing 'co' alias")
	}

	if !strings.Contains(output, "\tcob = checkout -b") {
		t.Error("Missing 'cob' alias")
	}
}

func TestGitconfigWriterSubsections(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"credential": map[string]interface{}{
			"https://github.com": map[string]interface{}{
				"helper": "!/opt/homebrew/bin/gh auth git-credential",
			},
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Check subsection format
	if !strings.Contains(output, `[credential "https://github.com"]`) {
		t.Errorf("Missing credential subsection\nGot:\n%s", output)
	}

	if !strings.Contains(output, "\thelper = !/opt/homebrew/bin/gh auth git-credential") {
		t.Error("Missing helper value")
	}
}

func TestGitconfigWriterMultiValueKeys(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"credential": map[string]interface{}{
			"https://github.com": map[string]interface{}{
				"helper": []interface{}{
					"",
					"!/opt/homebrew/bin/gh auth git-credential",
				},
			},
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Should have two helper lines
	helperCount := strings.Count(output, "\thelper = ")
	if helperCount != 2 {
		t.Errorf("Expected 2 helper lines, got %d\nOutput:\n%s", helperCount, output)
	}

	// First helper should be empty (clears previous)
	if !strings.Contains(output, "\thelper = \n") {
		t.Error("Missing empty helper line")
	}
}

func TestGitconfigWriterIncludeIf(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"includeIf": map[string]interface{}{
			"gitdir:~/Repos/work/": map[string]interface{}{
				"path": "~/.config/git/config.work",
			},
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, `[includeIf "gitdir:~/Repos/work/"]`) {
		t.Errorf("Missing includeIf section\nGot:\n%s", output)
	}

	if !strings.Contains(output, "\tpath = ~/.config/git/config.work") {
		t.Error("Missing path in includeIf")
	}
}

func TestGitconfigWriterMultipleIncludeIf(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"includeIf": map[string]interface{}{
			"gitdir:~/Repos/work/": map[string]interface{}{
				"path": "~/.config/git/config.work",
			},
			"gitdir:~/Repos/oss/": map[string]interface{}{
				"path": "~/.config/git/config.oss",
			},
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, `[includeIf "gitdir:~/Repos/work/"]`) {
		t.Error("Missing work includeIf")
	}

	if !strings.Contains(output, `[includeIf "gitdir:~/Repos/oss/"]`) {
		t.Error("Missing oss includeIf")
	}
}

func TestGitconfigWriterIncludeList(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"include": []interface{}{
			"~/.config/git/config.local",
			"~/.config/git/config.aliases",
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, "[include]") {
		t.Error("Missing [include] section")
	}

	if !strings.Contains(output, "\tpath = ~/.config/git/config.local") {
		t.Error("Missing first include path")
	}

	if !strings.Contains(output, "\tpath = ~/.config/git/config.aliases") {
		t.Error("Missing second include path")
	}
}

func TestGitconfigWriterBooleans(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{
		"core": map[string]interface{}{
			"autocrlf":    true,
			"safecrlf":    false,
			"ignorecase":  true,
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, "\tautocrlf = true") {
		t.Error("Boolean true not formatted correctly")
	}

	if !strings.Contains(output, "\tsafecrlf = false") {
		t.Error("Boolean false not formatted correctly")
	}
}

func TestGitconfigWriterEmptyValues(t *testing.T) {
	w := &GitconfigWriter{}

	values := map[string]interface{}{}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Should still have header
	if !strings.Contains(output, "# Git Configuration") {
		t.Error("Missing header even with empty values")
	}
}

func TestGitconfigWriterComplexConfig(t *testing.T) {
	w := &GitconfigWriter{}

	// Realistic git config
	values := map[string]interface{}{
		"core": map[string]interface{}{
			"editor": "nvim",
		},
		"user": map[string]interface{}{
			"name":  "MisterGrinvalds",
			"email": "8541275+MisterGrinvalds@users.noreply.github.com",
		},
		"color": map[string]interface{}{
			"ui": "auto",
		},
		"alias": map[string]interface{}{
			"s":  "status",
			"co": "checkout",
			"lg": "log --graph --pretty=format:'%h %s'",
		},
		"credential": map[string]interface{}{
			"https://github.com": map[string]interface{}{
				"helper": []interface{}{
					"",
					"!/opt/homebrew/bin/gh auth git-credential",
				},
			},
		},
		"includeIf": map[string]interface{}{
			"gitdir:~/Repos/work/": map[string]interface{}{
				"path": "~/.config/git/config.work",
			},
		},
	}

	content, err := w.Write(values)
	if err != nil {
		t.Fatalf("Write failed: %v", err)
	}

	output := string(content)

	// Verify all major sections
	if !strings.Contains(output, "[core]") {
		t.Error("Missing core section")
	}
	if !strings.Contains(output, "[user]") {
		t.Error("Missing user section")
	}
	if !strings.Contains(output, "[alias]") {
		t.Error("Missing alias section")
	}
	if !strings.Contains(output, `[credential "https://github.com"]`) {
		t.Error("Missing credential section")
	}
	if !strings.Contains(output, `[includeIf "gitdir:~/Repos/work/"]`) {
		t.Error("Missing includeIf section")
	}
}

func TestToGitconfigSlice(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected []string
		ok       bool
	}{
		{
			name:     "[]string",
			input:    []string{"a", "b", "c"},
			expected: []string{"a", "b", "c"},
			ok:       true,
		},
		{
			name:     "[]interface{} with strings",
			input:    []interface{}{"a", "b", "c"},
			expected: []string{"a", "b", "c"},
			ok:       true,
		},
		{
			name:     "string (not a slice)",
			input:    "just a string",
			expected: nil,
			ok:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, ok := toGitconfigSlice(tt.input)

			if ok != tt.ok {
				t.Errorf("toGitconfigSlice() ok = %v, want %v", ok, tt.ok)
				return
			}

			if tt.ok {
				if len(result) != len(tt.expected) {
					t.Errorf("toGitconfigSlice() len = %d, want %d", len(result), len(tt.expected))
					return
				}

				for i, v := range result {
					if v != tt.expected[i] {
						t.Errorf("toGitconfigSlice()[%d] = %q, want %q", i, v, tt.expected[i])
					}
				}
			}
		})
	}
}

func TestFormatGitconfigValue(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected string
	}{
		{
			name:     "string",
			input:    "nvim",
			expected: "nvim",
		},
		{
			name:     "bool true",
			input:    true,
			expected: "true",
		},
		{
			name:     "bool false",
			input:    false,
			expected: "false",
		},
		{
			name:     "integer",
			input:    42,
			expected: "42",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := formatGitconfigValue(tt.input)
			if result != tt.expected {
				t.Errorf("formatGitconfigValue(%v) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}
