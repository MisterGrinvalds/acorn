# Core shell component configuration
# Shell options, prompt, functions, and completions
# Note: Aliases are in bootstrap component to avoid duplication
# Note: Named "core" to avoid collision with "shell.sh" entrypoint
name: core
description: Core shell options, prompt, keybindings, and utility functions
version: 1.0.0

# Environment variables
env:
  # Pager settings
  PAGER: "less"
  LESS: "-R -F -X"
  # Claude / Anthropic
  ANTHROPIC_MODEL: "claude-opus-4-5-20251101[1m]"

# Shell functions
shell_functions:
  # Unalias conflicting names in zsh before defining functions
  # MUST be first init function
  __shell_unalias: |
    [ -n "$ZSH_VERSION" ] && {
        unalias h ff 2>/dev/null
    }

  # Initialize shell options - MUST run early
  # Sets shopt/setopt for history, navigation, globbing
  __shell_options: |
    case "$CURRENT_SHELL" in
        bash)
            # History options
            shopt -s histappend         # Append to history, don't overwrite
            shopt -s cmdhist            # Save multi-line commands as single entry

            # Directory navigation
            shopt -s autocd 2>/dev/null # cd by typing directory name (bash 4+)
            shopt -s cdspell            # Autocorrect typos in cd
            shopt -s dirspell 2>/dev/null  # Autocorrect directory names (bash 4+)

            # Globbing
            shopt -s globstar 2>/dev/null  # ** matches recursively (bash 4+)
            shopt -s nocaseglob         # Case-insensitive globbing
            shopt -s extglob            # Extended pattern matching

            # Misc
            shopt -s checkwinsize       # Update LINES/COLUMNS after each command
            shopt -s no_empty_cmd_completion  # Don't complete on empty line

            # History control
            export HISTCONTROL="erasedups:ignoredups:ignorespace"
            export HISTSIZE=10000
            export HISTFILESIZE=20000
            export HISTIGNORE="ls:ll:cd:pwd:bg:fg:history:clear:exit"
            ;;

        zsh)
            # History options
            setopt APPEND_HISTORY       # Append to history, don't overwrite
            setopt HIST_IGNORE_DUPS     # Don't store duplicates
            setopt HIST_IGNORE_SPACE    # Don't store commands starting with space
            setopt HIST_EXPIRE_DUPS_FIRST  # Remove duplicates first when trimming
            setopt HIST_FIND_NO_DUPS    # Don't show duplicates in search
            setopt SHARE_HISTORY        # Share history between sessions
            setopt EXTENDED_HISTORY     # Save timestamp

            # Directory navigation
            setopt AUTO_CD              # cd by typing directory name
            setopt AUTO_PUSHD           # Push directories onto stack
            setopt PUSHD_IGNORE_DUPS    # Don't push duplicates
            setopt PUSHD_SILENT         # Don't print directory stack
            setopt CDABLE_VARS          # cd to named directories

            # Globbing
            setopt EXTENDED_GLOB        # Extended pattern matching
            setopt NO_CASE_GLOB         # Case-insensitive globbing
            setopt GLOB_DOTS            # Include dotfiles in glob

            # Misc
            setopt CORRECT              # Spelling correction for commands
            setopt NO_BEEP              # Don't beep on errors
            setopt INTERACTIVE_COMMENTS # Allow comments in interactive shell

            # History settings
            export HISTSIZE=10000
            export SAVEHIST=20000
            ;;
    esac

  # Initialize color support
  __shell_colors: |
    case "$CURRENT_PLATFORM" in
        darwin)
            export CLICOLOR=1
            ;;
        linux)
            if command -v dircolors >/dev/null 2>&1; then
                eval "$(dircolors -b)"
            fi
            ;;
    esac

  # Initialize default editor
  __shell_editor: |
    if command -v nvim >/dev/null 2>&1; then
        export EDITOR='nvim'
        export VISUAL='nvim'
    elif command -v vim >/dev/null 2>&1; then
        export EDITOR='vim'
        export VISUAL='vim'
    else
        export EDITOR='vi'
        export VISUAL='vi'
    fi

  # Initialize FZF keybindings (Ctrl+R history search)
  __shell_fzf_keybindings: |
    if command -v fzf >/dev/null 2>&1; then
        case "$CURRENT_SHELL" in
            bash)
                # Ctrl+r: fzf history search
                __fzf_history__() {
                    local selected
                    selected=$(history | sed 's/^[ ]*[0-9]*[ ]*//' | fzf --tac --no-sort --reverse --query="$READLINE_LINE")
                    READLINE_LINE="$selected"
                    READLINE_POINT=${#READLINE_LINE}
                }
                bind -x '"\C-r": __fzf_history__'
                ;;
            zsh)
                # Ctrl+r: fzf history search
                fzf-history-widget() {
                    local selected
                    selected=$(fc -l 1 | sed 's/^[ ]*[0-9]*[ ]*//' | fzf --tac --no-sort --reverse --query="$LBUFFER")
                    if [[ -n "$selected" ]]; then
                        LBUFFER="$selected"
                    fi
                    zle reset-prompt
                }
                zle -N fzf-history-widget
                bindkey '^R' fzf-history-widget
                ;;
        esac
    fi

  # Initialize line editing keybindings (word navigation, home/end)
  __shell_keybindings: |
    case "$CURRENT_SHELL" in
        bash)
            # Word navigation (Alt+Left/Right)
            bind '"\e[1;3D": backward-word'
            bind '"\e[1;3C": forward-word'
            # Fallback sequences
            bind '"\eb": backward-word'
            bind '"\ef": forward-word'

            # Line navigation (Home/End)
            bind '"\e[H": beginning-of-line'
            bind '"\e[F": end-of-line'
            bind '"\e[1~": beginning-of-line'
            bind '"\e[4~": end-of-line'

            # Delete word (Alt+Backspace)
            bind '"\e\x7f": backward-kill-word'
            ;;

        zsh)
            # Word navigation (Alt+Left/Right)
            bindkey '\e[1;3D' backward-word
            bindkey '\e[1;3C' forward-word
            # Fallback sequences
            bindkey '\eb' backward-word
            bindkey '\ef' forward-word

            # Line navigation (Home/End)
            bindkey '\e[H' beginning-of-line
            bindkey '\e[F' end-of-line
            bindkey '\e[1~' beginning-of-line
            bindkey '\e[4~' end-of-line

            # Delete word (Alt+Backspace)
            bindkey '\e^?' backward-kill-word
            ;;
    esac

  # Initialize completions
  __shell_completions: |
    if [ "$CURRENT_SHELL" = "bash" ]; then
        # Suppress errors from completion scripts using bash 4.4+ features
        # macOS Homebrew bash-completion
        if [ -f "/opt/homebrew/etc/profile.d/bash_completion.sh" ]; then
            . "/opt/homebrew/etc/profile.d/bash_completion.sh" 2>/dev/null
        # Linux Homebrew bash-completion
        elif [ -f "/home/linuxbrew/.linuxbrew/etc/profile.d/bash_completion.sh" ]; then
            . "/home/linuxbrew/.linuxbrew/etc/profile.d/bash_completion.sh" 2>/dev/null
        # System bash-completion (Debian/Ubuntu)
        elif [ -f "/usr/share/bash-completion/bash_completion" ]; then
            . "/usr/share/bash-completion/bash_completion" 2>/dev/null
        # System bash-completion (older)
        elif [ -f "/etc/bash_completion" ]; then
            . "/etc/bash_completion" 2>/dev/null
        fi
    fi

    if [ "$CURRENT_SHELL" = "zsh" ]; then
        # Initialize zsh completion system
        autoload -Uz compinit

        # Use cached completion dump for faster startup
        _comp_cache="${XDG_CACHE_HOME:-$HOME/.cache}/zsh/zcompdump"
        mkdir -p "$(dirname "$_comp_cache")"

        if [ -f "$_comp_cache" ] && [ "$(find "$_comp_cache" -mtime -1 2>/dev/null)" ]; then
            compinit -C -d "$_comp_cache"
        else
            compinit -d "$_comp_cache"
        fi
        unset _comp_cache

        # Completion styling
        zstyle ':completion:*' menu select
        zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
        zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
        zstyle ':completion:*:descriptions' format '%F{green}-- %d --%f'
        zstyle ':completion:*:warnings' format '%F{red}No matches%f'
    fi

  # Initialize prompt - MUST run after theme is loaded
  __shell_prompt: |
    # Set terminal title to current directory
    _set_title() {
        printf '\033]0;%s\007' "${PWD/#$HOME/~}"
    }

    case "$CURRENT_SHELL" in
        bash)
            # Set title before each prompt
            PROMPT_COMMAND='_set_title'
            # Bash prompt using theme colors
            PS1='\['"$THEME_TEXT"'\]\n\['"$THEME_TEXT"'\]\A \['"$THEME_TEAL"'\]\u\['"$THEME_TEXT"'\] on \['"$THEME_SAPPHIRE"'\]\h\['"$THEME_TEXT"'\] \['"$THEME_BLUE"'\][\w]$(git_color)$(git_branch)\['"$THEME_RESET"'\]\n\$ '
            ;;
        zsh)
            # Zsh prompt using theme colors
            setopt PROMPT_SUBST
            # Set title before each prompt
            precmd() { _set_title; }
            # Build prompt with explicit newlines to avoid YAML % directive issue
            local _nl=$'\n'
            PROMPT="%{${THEME_TEXT}%}${_nl}%{${THEME_TEXT}%}%T %{${THEME_TEAL}%}%n%{${THEME_TEXT}%} on %{${THEME_SAPPHIRE}%}%m%{${THEME_TEXT}%} %{${THEME_BLUE}%}[%~]\$(git_color)\$(git_branch)%{${THEME_RESET}%}${_nl}%# "
            ;;
    esac

  # Git prompt helpers
  git_branch: |
    local branch
    branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [ -n "$branch" ]; then
        printf "(%s)" "$branch"
        return
    fi

    # Check for detached HEAD
    local commit
    commit=$(git rev-parse --short HEAD 2>/dev/null)
    if [ -n "$commit" ]; then
        printf "(%s)" "$commit"
    fi

  git_color: |
    local git_status
    git_status=$(git status --porcelain 2>/dev/null)

    # Check if we're in a git repo
    git rev-parse --git-dir >/dev/null 2>&1 || return

    if [ -n "$git_status" ]; then
        # Dirty - has uncommitted changes (Peach)
        printf '%b' "$THEME_GIT_DIRTY"
    elif git status 2>/dev/null | grep -q "Your branch is ahead"; then
        # Clean but ahead of remote (Red)
        printf '%b' "$THEME_GIT_AHEAD"
    else
        # Clean (Green)
        printf '%b' "$THEME_GIT_CLEAN"
    fi

  # Enhanced cd - automatically lists directory after changing
  cd: |
    builtin cd "$@" && ll

  # Make directory and cd into it
  mkcd: |
    mkdir -p "$1" && cd "$1"

  # Go up N directories
  up: |
    local count="${1:-1}"
    local path=""
    for _ in $(seq 1 "$count"); do
        path="${path}../"
    done
    cd "$path" || return

  # Extract various archive formats
  extract: |
    if [ -z "$1" ]; then
        echo "Usage: extract <file>"
        return 1
    fi

    if [ ! -f "$1" ]; then
        echo "'$1' is not a valid file"
        return 1
    fi

    case "$1" in
        *.tar.bz2) tar xjf "$1" ;;
        *.tar.gz)  tar xzf "$1" ;;
        *.tar.xz)  tar xJf "$1" ;;
        *.bz2)     bunzip2 "$1" ;;
        *.gz)      gunzip "$1" ;;
        *.tar)     tar xf "$1" ;;
        *.tbz2)    tar xjf "$1" ;;
        *.tgz)     tar xzf "$1" ;;
        *.zip)     unzip "$1" ;;
        *.Z)       uncompress "$1" ;;
        *.7z)      7z x "$1" ;;
        *.rar)     unrar x "$1" ;;
        *)         echo "'$1' cannot be extracted via extract()" ;;
    esac

  # Create a tar.gz archive
  mktar: |
    tar -czvf "${1%%/}.tar.gz" "${1%%/}/"

  # Create a zip archive
  mkzip: |
    zip -r "${1%%/}.zip" "${1%%/}/"

  # Shorthand for history with grep
  h: |
    history | grep "$1"

  # Find file by name
  ff: |
    find . -type f -iname "*$1*"

  # Find directory by name (renamed to avoid conflict with fd tool)
  fdir: |
    find . -type d -iname "*$1*"

  # Grep recursively (renamed to avoid conflict with ripgrep)
  rgrep: |
    grep -rn "$1" .

  # Show system info
  sysinfo: |
    echo "Hostname:  $(hostname)"
    echo "OS:        $(uname -s) $(uname -r)"
    echo "Shell:     $CURRENT_SHELL"
    echo "Platform:  $CURRENT_PLATFORM"
    echo "User:      $(whoami)"
    echo "Home:      $HOME"
    echo "Dotfiles:  $DOTFILES_ROOT"

  # Run a bash shell as another user
  bash_as: |
    sudo -u "$1" /bin/bash

  # Remove all environment variables matching pattern
  rmenv: |
    unset $(env | grep -i "${1:-prox}" | grep -oE '^[^=]+')
