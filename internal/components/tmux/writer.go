package tmux

import (
	"fmt"
	"sort"
	"strings"

	"github.com/mistergrinvalds/acorn/internal/utils/configfile"
)

// Writer implements the configfile.Writer interface for tmux config format.
// Tmux uses command-based syntax: set -g option value, bind key command, etc.
type Writer struct{}

func init() {
	configfile.Register(&Writer{})
}

// NewWriter creates a new tmux config writer.
func NewWriter() *Writer {
	return &Writer{}
}

// Format returns the format identifier.
func (w *Writer) Format() string {
	return "tmux"
}

// Write generates tmux config content from values.
// Expected structure:
//
//	set_g: map of global options (set -g)
//	set_s: map of server options (set -s)
//	set_w: map of window options (set -w)
//	set_ga: map of append options (set -ga)
//	set_as: list of append server options (set -as)
//	terminal_features: list of terminal feature strings
//	bind: map of prefix key bindings
//	bind_n: map of no-prefix key bindings
//	bind_r: map of repeatable key bindings
//	bind_T: map of table -> key -> command bindings
//	unbind: list of keys to unbind
//	unbind_n: list of no-prefix keys to unbind
//	plugins: list of TPM plugin strings
//	plugin_options: map of plugin options (@option)
//	raw: list of raw config lines (for conditionals, etc.)
//	run: list of commands to run
func (w *Writer) Write(values map[string]any) ([]byte, error) {
	var b strings.Builder

	b.WriteString("# =============================================================================\n")
	b.WriteString("# Tmux Configuration\n")
	b.WriteString("# =============================================================================\n")
	b.WriteString("# Generated by acorn - do not edit manually\n\n")

	// Write sections in order
	w.writeSetOptions(&b, values, "set_g", "-g", "General Settings")
	w.writeSetOptions(&b, values, "set_s", "-s", "Server Settings")
	w.writeSetOptions(&b, values, "set_w", "-w", "Window Settings")
	w.writeAppendOptions(&b, values)
	w.writeTerminalFeatures(&b, values)
	w.writeUnbinds(&b, values)
	w.writeBindings(&b, values)
	w.writeRaw(&b, values)
	w.writePlugins(&b, values)
	w.writeRun(&b, values)

	return []byte(b.String()), nil
}

// writeSetOptions writes set commands for a given flag.
func (w *Writer) writeSetOptions(b *strings.Builder, values map[string]any, key, flag, header string) {
	opts, ok := values[key].(map[string]any)
	if !ok || len(opts) == 0 {
		return
	}

	fmt.Fprintf(b, "# %s\n", header)

	keys := sortedKeys(opts)
	for _, k := range keys {
		v := opts[k]
		fmt.Fprintf(b, "set %s %s %s\n", flag, k, formatTmuxValue(v))
	}
	b.WriteString("\n")
}

// writeAppendOptions writes set -ga and set -as options.
func (w *Writer) writeAppendOptions(b *strings.Builder, values map[string]any) {
	// set -ga options
	if opts, ok := values["set_ga"].(map[string]any); ok && len(opts) > 0 {
		keys := sortedKeys(opts)
		for _, k := range keys {
			v := opts[k]
			fmt.Fprintf(b, "set -ga %s %s\n", k, formatTmuxValue(v))
		}
	}

	// set -as options (list format)
	if opts, ok := toStringSlice(values["set_as"]); ok {
		for _, opt := range opts {
			fmt.Fprintf(b, "set -as %s\n", opt)
		}
	}
	b.WriteString("\n")
}

// writeTerminalFeatures writes terminal-features settings.
func (w *Writer) writeTerminalFeatures(b *strings.Builder, values map[string]any) {
	features, ok := toStringSlice(values["terminal_features"])
	if !ok || len(features) == 0 {
		return
	}

	b.WriteString("# Terminal Features\n")
	for _, f := range features {
		fmt.Fprintf(b, "set -as terminal-features '%s'\n", f)
	}
	b.WriteString("\n")
}

// writeUnbinds writes unbind commands.
func (w *Writer) writeUnbinds(b *strings.Builder, values map[string]any) {
	hasUnbinds := false

	if keys, ok := toStringSlice(values["unbind"]); ok && len(keys) > 0 {
		if !hasUnbinds {
			b.WriteString("# Unbindings\n")
			hasUnbinds = true
		}
		for _, k := range keys {
			fmt.Fprintf(b, "unbind %s\n", k)
		}
	}

	if keys, ok := toStringSlice(values["unbind_n"]); ok && len(keys) > 0 {
		if !hasUnbinds {
			b.WriteString("# Unbindings\n")
			hasUnbinds = true
		}
		for _, k := range keys {
			fmt.Fprintf(b, "unbind -n %s\n", k)
		}
	}

	if hasUnbinds {
		b.WriteString("\n")
	}
}

// writeBindings writes key bindings.
func (w *Writer) writeBindings(b *strings.Builder, values map[string]any) {
	hasBindings := false

	// Regular prefix bindings
	if binds, ok := values["bind"].(map[string]any); ok && len(binds) > 0 {
		b.WriteString("# Key Bindings\n")
		hasBindings = true
		keys := sortedKeys(binds)
		for _, k := range keys {
			v := binds[k]
			fmt.Fprintf(b, "bind %s %s\n", k, formatTmuxValue(v))
		}
		b.WriteString("\n")
	}

	// No-prefix bindings
	if binds, ok := values["bind_n"].(map[string]any); ok && len(binds) > 0 {
		if !hasBindings {
			b.WriteString("# Key Bindings\n")
		}
		b.WriteString("# No-prefix bindings\n")
		keys := sortedKeys(binds)
		for _, k := range keys {
			v := binds[k]
			fmt.Fprintf(b, "bind -n %s %s\n", k, formatTmuxValue(v))
		}
		b.WriteString("\n")
	}

	// Repeatable bindings
	if binds, ok := values["bind_r"].(map[string]any); ok && len(binds) > 0 {
		b.WriteString("# Repeatable bindings\n")
		keys := sortedKeys(binds)
		for _, k := range keys {
			v := binds[k]
			fmt.Fprintf(b, "bind -r %s %s\n", k, formatTmuxValue(v))
		}
		b.WriteString("\n")
	}

	// Table-specific bindings (bind -T table key command)
	if tables, ok := values["bind_T"].(map[string]any); ok && len(tables) > 0 {
		for table, tableBinds := range tables {
			binds, ok := tableBinds.(map[string]any)
			if !ok {
				continue
			}
			fmt.Fprintf(b, "# %s bindings\n", table)
			keys := sortedKeys(binds)
			for _, k := range keys {
				v := binds[k]
				fmt.Fprintf(b, "bind -T %s %s %s\n", table, k, formatTmuxValue(v))
			}
			b.WriteString("\n")
		}
	}
}

// writeRaw writes raw config lines.
func (w *Writer) writeRaw(b *strings.Builder, values map[string]any) {
	raw, ok := toStringSlice(values["raw"])
	if !ok || len(raw) == 0 {
		return
	}

	for _, line := range raw {
		b.WriteString(line)
		b.WriteString("\n")
	}
	b.WriteString("\n")
}

// writePlugins writes TPM plugin configuration.
func (w *Writer) writePlugins(b *strings.Builder, values map[string]any) {
	plugins, ok := toStringSlice(values["plugins"])
	if !ok || len(plugins) == 0 {
		return
	}

	b.WriteString("# =============================================================================\n")
	b.WriteString("# TPM (Tmux Plugin Manager)\n")
	b.WriteString("# =============================================================================\n")
	b.WriteString("# Install: git clone https://github.com/tmux-plugins/tpm ~/.config/tmux/plugins/tpm\n")
	b.WriteString("# Press prefix + I to install plugins\n\n")

	for _, plugin := range plugins {
		fmt.Fprintf(b, "set -g @plugin '%s'\n", plugin)
	}

	// Plugin options
	if opts, ok := values["plugin_options"].(map[string]any); ok && len(opts) > 0 {
		b.WriteString("\n# Plugin settings\n")
		keys := sortedKeys(opts)
		for _, k := range keys {
			v := opts[k]
			fmt.Fprintf(b, "set -g @%s %s\n", k, formatTmuxValue(v))
		}
	}

	b.WriteString("\n")
}

// writeRun writes run commands (typically TPM initialization).
func (w *Writer) writeRun(b *strings.Builder, values map[string]any) {
	runs, ok := toStringSlice(values["run"])
	if !ok || len(runs) == 0 {
		return
	}

	b.WriteString("# Initialize plugins\n")
	for _, cmd := range runs {
		fmt.Fprintf(b, "run -b '%s'\n", cmd)
	}
}

// toStringSlice converts various list types to []string.
func toStringSlice(v any) ([]string, bool) {
	if v == nil {
		return nil, false
	}
	switch val := v.(type) {
	case []string:
		return val, true
	case []any:
		result := make([]string, 0, len(val))
		for _, item := range val {
			result = append(result, fmt.Sprintf("%v", item))
		}
		return result, true
	default:
		return nil, false
	}
}

// formatTmuxValue formats a value for tmux config.
func formatTmuxValue(v any) string {
	switch val := v.(type) {
	case string:
		return val
	case bool:
		if val {
			return "on"
		}
		return "off"
	case int, int64, float64:
		return fmt.Sprintf("%v", val)
	default:
		return fmt.Sprintf("%v", val)
	}
}

// sortedKeys returns sorted keys from a map.
func sortedKeys(m map[string]any) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}
