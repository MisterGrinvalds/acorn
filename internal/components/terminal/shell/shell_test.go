package shell

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	// Import component packages to register their config file writers
	_ "github.com/mistergrinvalds/acorn/internal/components/terminal/ghostty"
	_ "github.com/mistergrinvalds/acorn/internal/components/terminal/iterm2"
	_ "github.com/mistergrinvalds/acorn/internal/components/terminal/tmux"
	_ "github.com/mistergrinvalds/acorn/internal/components/vcs/git"
)

func TestNewConfig(t *testing.T) {
	config := NewConfig(true, false)

	if config.Verbose != true {
		t.Error("Verbose should be true")
	}

	if config.DryRun != false {
		t.Error("DryRun should be false")
	}

	if config.AcornDir == "" {
		t.Error("AcornDir should not be empty")
	}

	if config.Shell == "" {
		t.Error("Shell should not be empty")
	}

	if config.Platform == "" {
		t.Error("Platform should not be empty")
	}
}

func TestNewManager(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	if manager == nil {
		t.Fatal("NewManager returned nil")
	}

	if manager.config != config {
		t.Error("Manager config not set correctly")
	}

	if manager.components == nil {
		t.Error("Manager components map should be initialized")
	}

	if manager.fileSpecs == nil {
		t.Error("Manager fileSpecs map should be initialized")
	}
}

func TestRegisterComponent(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	component := &Component{
		Name:        "test",
		Description: "Test component",
	}

	manager.RegisterComponent(component)

	if len(manager.components) != 1 {
		t.Errorf("Expected 1 component, got %d", len(manager.components))
	}

	retrieved, ok := manager.GetComponent("test")
	if !ok {
		t.Error("Component not found after registration")
	}

	if retrieved.Name != "test" {
		t.Errorf("Component name = %q, want %q", retrieved.Name, "test")
	}
}

func TestRegisterComponentFiles(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	files := []FileSpec{
		{
			Target: "/path/to/config",
			Format: "ghostty",
			Values: map[string]interface{}{"key": "value"},
		},
	}

	manager.RegisterComponentFiles("test", files)

	if len(manager.fileSpecs) != 1 {
		t.Errorf("Expected 1 fileSpec entry, got %d", len(manager.fileSpecs))
	}

	if len(manager.fileSpecs["test"]) != 1 {
		t.Errorf("Expected 1 file for test component, got %d", len(manager.fileSpecs["test"]))
	}
}

func TestRegisterComponentFilesEmpty(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	// Empty files should not be registered
	manager.RegisterComponentFiles("test", []FileSpec{})

	if len(manager.fileSpecs) != 0 {
		t.Error("Empty files should not be registered")
	}

	manager.RegisterComponentFiles("test", nil)

	if len(manager.fileSpecs) != 0 {
		t.Error("Nil files should not be registered")
	}
}

func TestListComponents(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	manager.RegisterComponent(&Component{Name: "zebra"})
	manager.RegisterComponent(&Component{Name: "alpha"})
	manager.RegisterComponent(&Component{Name: "middle"})

	list := manager.ListComponents()

	if len(list) != 3 {
		t.Fatalf("Expected 3 components, got %d", len(list))
	}

	// Should be sorted
	if list[0] != "alpha" || list[1] != "middle" || list[2] != "zebra" {
		t.Errorf("Components not sorted: %v", list)
	}
}

func TestGetComponentNotFound(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	_, ok := manager.GetComponent("nonexistent")
	if ok {
		t.Error("GetComponent should return false for nonexistent component")
	}
}

func TestGenerateComponentScript(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	component := &Component{
		Name:        "test",
		Description: "Test component",
		Env:         "export TEST_VAR=value\n",
		Aliases:     "alias t='test'\n",
		Functions:   "test_func() { echo 'test'; }\n",
	}

	script := manager.generateComponentScript(component)

	if !strings.Contains(script, "#!/bin/sh") {
		t.Error("Missing shebang")
	}

	if !strings.Contains(script, "# Acorn shell integration: test") {
		t.Error("Missing component name comment")
	}

	if !strings.Contains(script, "# Test component") {
		t.Error("Missing description comment")
	}

	if !strings.Contains(script, "# Generated by acorn") {
		t.Error("Missing generated comment")
	}

	if !strings.Contains(script, "export TEST_VAR=value") {
		t.Error("Missing environment section")
	}

	if !strings.Contains(script, "alias t='test'") {
		t.Error("Missing aliases section")
	}

	if !strings.Contains(script, "test_func()") {
		t.Error("Missing functions section")
	}
}

func TestGenerateComponentDryRun(t *testing.T) {
	config := NewConfig(false, true) // dry run = true
	manager := NewManager(config)

	manager.RegisterComponent(&Component{
		Name:        "test",
		Description: "Test",
	})

	result, err := manager.GenerateComponent("test")
	if err != nil {
		t.Fatalf("GenerateComponent failed: %v", err)
	}

	if result.DryRun != true {
		t.Error("Result should indicate dry run")
	}

	if len(result.Scripts) != 1 {
		t.Fatalf("Expected 1 script, got %d", len(result.Scripts))
	}

	if result.Scripts[0].Written {
		t.Error("Script should not be written in dry run mode")
	}
}

func TestGenerateComponentWithFiles(t *testing.T) {
	// Create temp directory for actual file writing test
	tmpDir, err := os.MkdirTemp("", "shell-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	config := &Config{
		AcornDir: tmpDir,
		Shell:    "bash",
		Platform: "darwin",
		DryRun:   true, // dry run so we don't actually write
	}
	manager := NewManager(config)

	manager.RegisterComponent(&Component{
		Name:        "test",
		Description: "Test",
	})

	manager.RegisterComponentFiles("test", []FileSpec{
		{
			Target: filepath.Join(tmpDir, "config"),
			Format: "ghostty",
			Values: map[string]interface{}{"theme": "dark"},
		},
	})

	result, err := manager.GenerateComponents("test")
	if err != nil {
		t.Fatalf("GenerateComponents failed: %v", err)
	}

	if len(result.ConfigFiles) != 1 {
		t.Fatalf("Expected 1 config file, got %d", len(result.ConfigFiles))
	}

	if result.ConfigFiles[0].Format != "ghostty" {
		t.Errorf("Format = %q, want %q", result.ConfigFiles[0].Format, "ghostty")
	}
}

func TestGenerateComponentNotFound(t *testing.T) {
	config := NewConfig(false, true)
	manager := NewManager(config)

	_, err := manager.GenerateComponent("nonexistent")
	if err == nil {
		t.Error("GenerateComponent should fail for nonexistent component")
	}
}

func TestGenerateComponentsAll(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "shell-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	config := &Config{
		AcornDir: tmpDir,
		Shell:    "bash",
		Platform: "darwin",
		DryRun:   true,
	}
	manager := NewManager(config)

	manager.RegisterComponent(&Component{Name: "comp1", Description: "Comp 1"})
	manager.RegisterComponent(&Component{Name: "comp2", Description: "Comp 2"})

	// No args = all components
	result, err := manager.GenerateComponents()
	if err != nil {
		t.Fatalf("GenerateComponents failed: %v", err)
	}

	if len(result.Scripts) != 2 {
		t.Errorf("Expected 2 scripts, got %d", len(result.Scripts))
	}
}

func TestGenerateAll(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "shell-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	config := &Config{
		AcornDir: tmpDir,
		Shell:    "bash",
		Platform: "darwin",
		DryRun:   true,
	}
	manager := NewManager(config)

	manager.RegisterComponent(&Component{Name: "test", Description: "Test"})

	result, err := manager.GenerateAll()
	if err != nil {
		t.Fatalf("GenerateAll failed: %v", err)
	}

	if result.Entrypoint == nil {
		t.Error("Entrypoint should be generated")
	}

	if result.Entrypoint.Component != "shell" {
		t.Errorf("Entrypoint component = %q, want %q", result.Entrypoint.Component, "shell")
	}
}

func TestGenerateEntrypoint(t *testing.T) {
	config := &Config{
		AcornDir: "/home/user/.config/acorn",
		Shell:    "zsh",
		Platform: "darwin",
	}
	manager := NewManager(config)

	manager.RegisterComponent(&Component{Name: "go"})
	manager.RegisterComponent(&Component{Name: "python"})

	entrypoint := manager.generateEntrypoint()

	if !strings.Contains(entrypoint, "#!/bin/sh") {
		t.Error("Missing shebang")
	}

	if !strings.Contains(entrypoint, "ACORN_CONFIG_DIR=") {
		t.Error("Missing ACORN_CONFIG_DIR")
	}

	if !strings.Contains(entrypoint, "go.sh") {
		t.Error("Missing go.sh sourcing")
	}

	if !strings.Contains(entrypoint, "python.sh") {
		t.Error("Missing python.sh sourcing")
	}

	// zsh completions
	if !strings.Contains(entrypoint, "completion zsh") {
		t.Error("Missing zsh completion")
	}
}

func TestGenerateEntrypointBash(t *testing.T) {
	config := &Config{
		AcornDir: "/home/user/.config/acorn",
		Shell:    "bash",
		Platform: "linux",
	}
	manager := NewManager(config)

	entrypoint := manager.generateEntrypoint()

	if !strings.Contains(entrypoint, "completion bash") {
		t.Error("Should use bash completion for bash shell")
	}
}

func TestFileSpec(t *testing.T) {
	spec := FileSpec{
		Target: "/path/to/config",
		Format: "ghostty",
		Values: map[string]interface{}{
			"theme":     "dark",
			"font-size": 14,
		},
	}

	if spec.Target != "/path/to/config" {
		t.Errorf("Target = %q", spec.Target)
	}

	if spec.Format != "ghostty" {
		t.Errorf("Format = %q", spec.Format)
	}

	if spec.Values["theme"] != "dark" {
		t.Errorf("Values[theme] = %v", spec.Values["theme"])
	}
}

func TestComponentConfigFromSpec(t *testing.T) {
	spec := FileSpec{
		Target: "/path/to/config",
		Format: "ghostty",
		Values: map[string]interface{}{"key": "value"},
	}

	fc := componentConfigFromSpec(spec)

	if fc.Target != spec.Target {
		t.Errorf("Target = %q, want %q", fc.Target, spec.Target)
	}

	if fc.Format != spec.Format {
		t.Errorf("Format = %q, want %q", fc.Format, spec.Format)
	}

	if fc.Values["key"] != spec.Values["key"] {
		t.Errorf("Values mismatch")
	}
}

func TestGetRCFile(t *testing.T) {
	home, _ := os.UserHomeDir()

	tests := []struct {
		name     string
		shell    string
		platform string
		expected string
	}{
		{"zsh on darwin", "zsh", "darwin", filepath.Join(home, ".zshrc")},
		{"zsh on linux", "zsh", "linux", filepath.Join(home, ".zshrc")},
		{"bash on darwin", "bash", "darwin", filepath.Join(home, ".bash_profile")},
		{"bash on linux", "bash", "linux", filepath.Join(home, ".bashrc")},
		{"unknown shell on linux", "unknown", "linux", filepath.Join(home, ".bashrc")},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			config := &Config{Shell: tt.shell, Platform: tt.platform}
			manager := NewManager(config)

			rcFile := manager.GetRCFile()
			if rcFile != tt.expected {
				t.Errorf("GetRCFile() = %q, want %q", rcFile, tt.expected)
			}
		})
	}
}

func TestInjectMarkers(t *testing.T) {
	if InjectMarker == "" {
		t.Error("InjectMarker should not be empty")
	}

	if InjectMarkerEnd == "" {
		t.Error("InjectMarkerEnd should not be empty")
	}

	if !strings.Contains(InjectMarker, "acorn") {
		t.Error("InjectMarker should contain 'acorn'")
	}

	if !strings.Contains(InjectMarkerEnd, "acorn") {
		t.Error("InjectMarkerEnd should contain 'acorn'")
	}
}
