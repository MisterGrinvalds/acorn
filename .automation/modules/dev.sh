#!/bin/bash
# Development Workflow Automation Module

# Module configuration
readonly DEV_TEMPLATES_DIR="$AUTO_HOME/templates"
readonly DEV_PROJECTS_DIR="${DEV_PROJECTS_DIR:-$HOME/projects}"

# Initialize templates directory
mkdir -p "$DEV_TEMPLATES_DIR"

# Help function for dev module
dev_help() {
    cat << EOF
Development Workflow Automation

USAGE:
    auto dev <command> [options]

COMMANDS:
    init <language> <project-name>   Initialize new project
    setup                           Setup development environment
    test [type]                     Run tests (unit, integration, all)
    build [target]                  Build project
    deploy <environment>            Deploy to environment
    format                          Format code
    lint                           Run linting
    deps                           Manage dependencies
    env <action>                   Manage environments
    templates                      Manage project templates

LANGUAGES SUPPORTED:
    python      Python with FastAPI/Flask
    go          Go with Cobra CLI
    typescript  TypeScript/Node.js
    react       React application
    next        Next.js application

EXAMPLES:
    auto dev init python my-api
    auto dev init go my-cli-tool
    auto dev test unit
    auto dev deploy staging
    auto dev env create production
EOF
}

# Project initialization functions
init_python_project() {
    local project_name="$1"
    local template="${2:-fastapi}"
    
    log "INFO" "Initializing Python project: $project_name"
    
    mkdir -p "$DEV_PROJECTS_DIR/$project_name"
    cd "$DEV_PROJECTS_DIR/$project_name"
    
    # Create virtual environment
    python3 -m venv .venv
    source .venv/bin/activate
    
    # Install base dependencies based on template
    case "$template" in
        "fastapi")
            pip install fastapi uvicorn python-multipart
            pip install pytest httpx pytest-asyncio black isort flake8
            pip install python-dotenv pydantic-settings
            
            # Create FastAPI structure
            mkdir -p app/{api,core,models,schemas,services}
            
            cat > app/main.py << 'EOF'
from fastapi import FastAPI
from app.core.config import settings

app = FastAPI(title=settings.PROJECT_NAME, version=settings.VERSION)

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
EOF

            cat > app/core/__init__.py << 'EOF'
EOF

            cat > app/core/config.py << 'EOF'
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    PROJECT_NAME: str = "FastAPI Project"
    VERSION: str = "0.1.0"
    DEBUG: bool = False
    
    class Config:
        env_file = ".env"

settings = Settings()
EOF
            ;;
        "flask")
            pip install flask flask-restful
            pip install pytest black isort flake8
            
            cat > app.py << 'EOF'
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return {"message": "Hello World"}

if __name__ == '__main__':
    app.run(debug=True)
EOF
            ;;
    esac
    
    # Common Python project files
    cat > requirements.txt << 'EOF'
# Generated by auto dev init
# Add your project dependencies here
EOF

    cat > .env.example << 'EOF'
# Environment variables template
DEBUG=true
LOG_LEVEL=info
EOF

    cat > pytest.ini << 'EOF'
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --tb=short
EOF

    cat > .gitignore << 'EOF'
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
.env
.venv
venv/
ENV/
env/
.pytest_cache/
.coverage
htmlcov/
.DS_Store
EOF

    mkdir -p tests
    cat > tests/test_main.py << 'EOF'
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_root():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}

def test_health():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}
EOF

    # Create VS Code settings
    mkdir -p .vscode
    cat > .vscode/settings.json << 'EOF'
{
    "python.defaultInterpreterPath": "./.venv/bin/python",
    "python.terminal.activateEnvironment": true,
    "python.formatting.provider": "black",
    "python.sortImports.args": ["--profile", "black"],
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": true
    },
    "python.testing.pytestEnabled": true,
    "python.testing.unittestEnabled": false
}
EOF

    log "SUCCESS" "Python project '$project_name' created successfully"
    log "INFO" "Run: cd $DEV_PROJECTS_DIR/$project_name && source .venv/bin/activate"
}

init_go_project() {
    local project_name="$1"
    local module_name="${2:-github.com/$(whoami)/$project_name}"
    
    log "INFO" "Initializing Go project: $project_name"
    
    mkdir -p "$DEV_PROJECTS_DIR/$project_name"
    cd "$DEV_PROJECTS_DIR/$project_name"
    
    # Initialize Go module
    go mod init "$module_name"
    
    # Create basic structure
    mkdir -p {cmd,internal,pkg,api,web,configs,scripts,deployments,test}
    
    # Create main.go
    cat > main.go << 'EOF'
package main

import (
    "fmt"
    "log"
)

func main() {
    fmt.Println("Hello, World!")
}
EOF

    # Create Cobra CLI structure if requested
    if command_exists cobra-cli; then
        cobra-cli init --license apache
        cobra-cli add serve
        cobra-cli add version
    fi
    
    # Create Makefile
    cat > Makefile << 'EOF'
.PHONY: build test clean run fmt lint

# Build the application
build:
	go build -o bin/app .

# Run tests
test:
	go test -v ./...

# Run tests with coverage
test-coverage:
	go test -v -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html

# Clean build artifacts
clean:
	rm -rf bin/
	rm -f coverage.out coverage.html

# Run the application
run:
	go run .

# Format code
fmt:
	go fmt ./...

# Lint code
lint:
	golangci-lint run

# Install dependencies
deps:
	go mod tidy
	go mod download

# Build for multiple platforms
build-all:
	GOOS=linux GOARCH=amd64 go build -o bin/app-linux-amd64 .
	GOOS=darwin GOARCH=amd64 go build -o bin/app-darwin-amd64 .
	GOOS=windows GOARCH=amd64 go build -o bin/app-windows-amd64.exe .
EOF

    # Create .gitignore
    cat > .gitignore << 'EOF'
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
bin/
dist/

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out
coverage.html

# Go workspace file
go.work

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Environment
.env
.env.local
EOF

    # Create VS Code settings
    mkdir -p .vscode
    cat > .vscode/settings.json << 'EOF'
{
    "go.formatTool": "goimports",
    "go.lintTool": "golangci-lint",
    "editor.formatOnSave": true,
    "go.testFlags": ["-v"],
    "go.testTimeout": "30s"
}
EOF

    log "SUCCESS" "Go project '$project_name' created successfully"
    log "INFO" "Run: cd $DEV_PROJECTS_DIR/$project_name"
}

init_typescript_project() {
    local project_name="$1"
    local template="${2:-express}"
    
    log "INFO" "Initializing TypeScript project: $project_name"
    
    mkdir -p "$DEV_PROJECTS_DIR/$project_name"
    cd "$DEV_PROJECTS_DIR/$project_name"
    
    # Initialize package.json
    npm init -y
    
    # Install TypeScript and common dependencies
    npm install --save-dev typescript @types/node ts-node nodemon
    npm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
    npm install --save-dev prettier jest @types/jest ts-jest
    
    case "$template" in
        "express")
            npm install express
            npm install --save-dev @types/express
            
            cat > src/index.ts << 'EOF'
import express from 'express';

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
    res.json({ message: 'Hello World!' });
});

app.get('/health', (req, res) => {
    res.json({ status: 'healthy' });
});

app.listen(port, () => {
    console.log(`Server running on port ${port}`);
});
EOF
            ;;
        "cli")
            npm install commander
            
            cat > src/index.ts << 'EOF'
#!/usr/bin/env node
import { Command } from 'commander';

const program = new Command();

program
    .name('my-cli')
    .description('CLI tool description')
    .version('1.0.0');

program
    .command('hello <name>')
    .description('Say hello to someone')
    .action((name) => {
        console.log(`Hello, ${name}!`);
    });

program.parse();
EOF
            ;;
    esac
    
    mkdir -p src
    
    # TypeScript config
    cat > tsconfig.json << 'EOF'
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
}
EOF

    # Update package.json scripts
    cat > package.json << EOF
{
    "name": "$project_name",
    "version": "1.0.0",
    "description": "",
    "main": "dist/index.js",
    "scripts": {
        "build": "tsc",
        "start": "node dist/index.js",
        "dev": "nodemon src/index.ts",
        "test": "jest",
        "lint": "eslint src/**/*.ts",
        "format": "prettier --write src/**/*.ts"
    },
    "keywords": [],
    "author": "",
    "license": "MIT"
}
EOF

    # Create .gitignore
    cat > .gitignore << 'EOF'
node_modules/
dist/
*.log
.env
.env.local
.DS_Store
coverage/
.nyc_output/
EOF

    log "SUCCESS" "TypeScript project '$project_name' created successfully"
    log "INFO" "Run: cd $DEV_PROJECTS_DIR/$project_name && npm run dev"
}

# Main dev module function
dev_main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        "help"|"-h"|"--help")
            dev_help
            ;;
        "init")
            local language="$1"
            local project_name="$2"
            
            if [ -z "$language" ] || [ -z "$project_name" ]; then
                log "ERROR" "Usage: auto dev init <language> <project-name>"
                exit 1
            fi
            
            case "$language" in
                "python"|"py")
                    init_python_project "$project_name" "${3:-fastapi}"
                    ;;
                "go"|"golang")
                    init_go_project "$project_name" "$3"
                    ;;
                "typescript"|"ts"|"node")
                    init_typescript_project "$project_name" "${3:-express}"
                    ;;
                *)
                    log "ERROR" "Unsupported language: $language"
                    log "INFO" "Supported languages: python, go, typescript"
                    exit 1
                    ;;
            esac
            ;;
        "test")
            local test_type="${1:-all}"
            
            if [ -f "package.json" ]; then
                npm test
            elif [ -f "go.mod" ]; then
                go test ./...
            elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
                pytest
            else
                log "ERROR" "No supported project type detected"
                exit 1
            fi
            ;;
        "build")
            if [ -f "package.json" ]; then
                npm run build
            elif [ -f "go.mod" ]; then
                go build .
            elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
                log "INFO" "Python projects typically don't need building"
            else
                log "ERROR" "No supported project type detected"
                exit 1
            fi
            ;;
        "format")
            if [ -f "package.json" ]; then
                npm run format 2>/dev/null || npx prettier --write .
            elif [ -f "go.mod" ]; then
                go fmt ./...
            elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
                black . && isort .
            fi
            ;;
        *)
            log "ERROR" "Unknown command: $command"
            dev_help
            exit 1
            ;;
    esac
}